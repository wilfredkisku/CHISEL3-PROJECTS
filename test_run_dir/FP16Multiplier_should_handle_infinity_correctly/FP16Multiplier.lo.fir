FIRRTL version 1.1.0
circuit FP16Multiplier :
  module FP16Multiplier :
    input clock : Clock
    input reset : UInt<1>
    input io_a : UInt<16>
    input io_b : UInt<16>
    output io_result : UInt<16>

    node signA = bits(io_a, 15, 15) @[FloatingPointMultiply.scala 13:18]
    node expA = bits(io_a, 14, 10) @[FloatingPointMultiply.scala 14:22]
    node _significand_T = bits(io_a, 9, 0) @[FloatingPointMultiply.scala 15:42]
    node sigA = cat(UInt<1>("h1"), _significand_T) @[Cat.scala 33:92]
    node signB = bits(io_b, 15, 15) @[FloatingPointMultiply.scala 13:18]
    node expB = bits(io_b, 14, 10) @[FloatingPointMultiply.scala 14:22]
    node _significand_T_1 = bits(io_b, 9, 0) @[FloatingPointMultiply.scala 15:42]
    node sigB = cat(UInt<1>("h1"), _significand_T_1) @[Cat.scala 33:92]
    node newSign = xor(signA, signB) @[FloatingPointMultiply.scala 23:23]
    node _isZeroA_T = eq(expA, UInt<1>("h0")) @[FloatingPointMultiply.scala 26:22]
    node _isZeroA_T_1 = bits(io_a, 9, 0) @[FloatingPointMultiply.scala 26:37]
    node _isZeroA_T_2 = eq(_isZeroA_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 26:44]
    node isZeroA = and(_isZeroA_T, _isZeroA_T_2) @[FloatingPointMultiply.scala 26:30]
    node _isZeroB_T = eq(expB, UInt<1>("h0")) @[FloatingPointMultiply.scala 27:22]
    node _isZeroB_T_1 = bits(io_b, 9, 0) @[FloatingPointMultiply.scala 27:37]
    node _isZeroB_T_2 = eq(_isZeroB_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 27:44]
    node isZeroB = and(_isZeroB_T, _isZeroB_T_2) @[FloatingPointMultiply.scala 27:30]
    node isInfA = eq(expA, UInt<5>("h1f")) @[FloatingPointMultiply.scala 28:21]
    node isInfB = eq(expB, UInt<5>("h1f")) @[FloatingPointMultiply.scala 29:21]
    node _isDenormA_T = eq(expA, UInt<1>("h0")) @[FloatingPointMultiply.scala 30:24]
    node _isDenormA_T_1 = bits(io_a, 9, 0) @[FloatingPointMultiply.scala 30:39]
    node _isDenormA_T_2 = neq(_isDenormA_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 30:46]
    node isDenormA = and(_isDenormA_T, _isDenormA_T_2) @[FloatingPointMultiply.scala 30:32]
    node _isDenormB_T = eq(expB, UInt<1>("h0")) @[FloatingPointMultiply.scala 31:24]
    node _isDenormB_T_1 = bits(io_b, 9, 0) @[FloatingPointMultiply.scala 31:39]
    node _isDenormB_T_2 = neq(_isDenormB_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 31:46]
    node isDenormB = and(_isDenormB_T, _isDenormB_T_2) @[FloatingPointMultiply.scala 31:32]
    node _T = or(isZeroA, isZeroB) @[FloatingPointMultiply.scala 33:16]
    node _io_result_T = cat(newSign, UInt<15>("h0")) @[Cat.scala 33:92]
    node _T_1 = or(isInfA, isInfB) @[FloatingPointMultiply.scala 36:21]
    node io_result_hi = cat(newSign, UInt<5>("h1f")) @[Cat.scala 33:92]
    node _io_result_T_1 = cat(io_result_hi, UInt<10>("h0")) @[Cat.scala 33:92]
    node _expResult_T = cvt(expA) @[FloatingPointMultiply.scala 41:31]
    node _expResult_T_1 = cvt(expB) @[FloatingPointMultiply.scala 41:45]
    node _expResult_T_2 = add(_expResult_T, _expResult_T_1) @[FloatingPointMultiply.scala 41:34]
    node _expResult_T_3 = tail(_expResult_T_2, 1) @[FloatingPointMultiply.scala 41:34]
    node _expResult_T_4 = asSInt(_expResult_T_3) @[FloatingPointMultiply.scala 41:34]
    node _expResult_T_5 = cvt(UInt<4>("hf")) @[FloatingPointMultiply.scala 41:65]
    node _expResult_T_6 = sub(_expResult_T_4, _expResult_T_5) @[FloatingPointMultiply.scala 41:48]
    node _expResult_T_7 = tail(_expResult_T_6, 1) @[FloatingPointMultiply.scala 41:48]
    node _expResult_T_8 = asSInt(_expResult_T_7) @[FloatingPointMultiply.scala 41:48]
    node expResult = asUInt(_expResult_T_8) @[FloatingPointMultiply.scala 41:75]
    node _sigResult_T = mul(sigA, sigB) @[FloatingPointMultiply.scala 42:27]
    node sigResult = bits(_sigResult_T, 21, 10) @[FloatingPointMultiply.scala 42:34]
    node _T_2 = bits(expResult, 5, 5) @[FloatingPointMultiply.scala 45:19]
    node _T_3 = gt(expResult, UInt<5>("h1e")) @[FloatingPointMultiply.scala 48:26]
    node io_result_hi_1 = cat(newSign, UInt<5>("h1f")) @[Cat.scala 33:92]
    node _io_result_T_2 = cat(io_result_hi_1, UInt<10>("h0")) @[Cat.scala 33:92]
    node _io_result_T_3 = bits(expResult, 4, 0) @[FloatingPointMultiply.scala 53:42]
    node _io_result_T_4 = bits(sigResult, 9, 0) @[FloatingPointMultiply.scala 53:59]
    node io_result_hi_2 = cat(newSign, _io_result_T_3) @[Cat.scala 33:92]
    node _io_result_T_5 = cat(io_result_hi_2, _io_result_T_4) @[Cat.scala 33:92]
    node _GEN_0 = mux(_T_3, _io_result_T_2, _io_result_T_5) @[FloatingPointMultiply.scala 48:40 50:17 53:17]
    node _GEN_1 = mux(_T_2, UInt<1>("h0"), _GEN_0) @[FloatingPointMultiply.scala 45:24 47:17]
    node _GEN_2 = mux(_T_1, _io_result_T_1, _GEN_1) @[FloatingPointMultiply.scala 36:32 38:15]
    node _GEN_3 = mux(_T, _io_result_T, _GEN_2) @[FloatingPointMultiply.scala 33:28 35:15]
    io_result <= _GEN_3
