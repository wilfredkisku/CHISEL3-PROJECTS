circuit FP16Multiplier :
  module FP16Multiplier :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip a : UInt<16>, flip b : UInt<16>, result : UInt<16>}

    node signA = bits(io.a, 15, 15) @[FloatingPointMultiply.scala 13:18]
    node expA = bits(io.a, 14, 10) @[FloatingPointMultiply.scala 14:22]
    node _significand_T = bits(io.a, 9, 0) @[FloatingPointMultiply.scala 15:42]
    node sigA = cat(UInt<1>("h1"), _significand_T) @[Cat.scala 33:92]
    node signB = bits(io.b, 15, 15) @[FloatingPointMultiply.scala 13:18]
    node expB = bits(io.b, 14, 10) @[FloatingPointMultiply.scala 14:22]
    node _significand_T_1 = bits(io.b, 9, 0) @[FloatingPointMultiply.scala 15:42]
    node sigB = cat(UInt<1>("h1"), _significand_T_1) @[Cat.scala 33:92]
    node newSign = xor(signA, signB) @[FloatingPointMultiply.scala 23:23]
    node _isZeroA_T = eq(expA, UInt<1>("h0")) @[FloatingPointMultiply.scala 26:22]
    node _isZeroA_T_1 = bits(io.a, 9, 0) @[FloatingPointMultiply.scala 26:37]
    node _isZeroA_T_2 = eq(_isZeroA_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 26:44]
    node isZeroA = and(_isZeroA_T, _isZeroA_T_2) @[FloatingPointMultiply.scala 26:30]
    node _isZeroB_T = eq(expB, UInt<1>("h0")) @[FloatingPointMultiply.scala 27:22]
    node _isZeroB_T_1 = bits(io.b, 9, 0) @[FloatingPointMultiply.scala 27:37]
    node _isZeroB_T_2 = eq(_isZeroB_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 27:44]
    node isZeroB = and(_isZeroB_T, _isZeroB_T_2) @[FloatingPointMultiply.scala 27:30]
    node isInfA = eq(expA, UInt<5>("h1f")) @[FloatingPointMultiply.scala 28:21]
    node isInfB = eq(expB, UInt<5>("h1f")) @[FloatingPointMultiply.scala 29:21]
    node _isDenormA_T = eq(expA, UInt<1>("h0")) @[FloatingPointMultiply.scala 30:24]
    node _isDenormA_T_1 = bits(io.a, 9, 0) @[FloatingPointMultiply.scala 30:39]
    node _isDenormA_T_2 = neq(_isDenormA_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 30:46]
    node isDenormA = and(_isDenormA_T, _isDenormA_T_2) @[FloatingPointMultiply.scala 30:32]
    node _isDenormB_T = eq(expB, UInt<1>("h0")) @[FloatingPointMultiply.scala 31:24]
    node _isDenormB_T_1 = bits(io.b, 9, 0) @[FloatingPointMultiply.scala 31:39]
    node _isDenormB_T_2 = neq(_isDenormB_T_1, UInt<1>("h0")) @[FloatingPointMultiply.scala 31:46]
    node isDenormB = and(_isDenormB_T, _isDenormB_T_2) @[FloatingPointMultiply.scala 31:32]
    node _T = or(isZeroA, isZeroB) @[FloatingPointMultiply.scala 33:16]
    when _T : @[FloatingPointMultiply.scala 33:28]
      node _io_result_T = cat(newSign, UInt<15>("h0")) @[Cat.scala 33:92]
      io.result <= _io_result_T @[FloatingPointMultiply.scala 35:15]
    else :
      node _T_1 = or(isInfA, isInfB) @[FloatingPointMultiply.scala 36:21]
      when _T_1 : @[FloatingPointMultiply.scala 36:32]
        node io_result_hi = cat(newSign, UInt<5>("h1f")) @[Cat.scala 33:92]
        node _io_result_T_1 = cat(io_result_hi, UInt<10>("h0")) @[Cat.scala 33:92]
        io.result <= _io_result_T_1 @[FloatingPointMultiply.scala 38:15]
      else :
        node _expResult_T = cvt(expA) @[FloatingPointMultiply.scala 41:31]
        node _expResult_T_1 = cvt(expB) @[FloatingPointMultiply.scala 41:45]
        node _expResult_T_2 = add(_expResult_T, _expResult_T_1) @[FloatingPointMultiply.scala 41:34]
        node _expResult_T_3 = tail(_expResult_T_2, 1) @[FloatingPointMultiply.scala 41:34]
        node _expResult_T_4 = asSInt(_expResult_T_3) @[FloatingPointMultiply.scala 41:34]
        node _expResult_T_5 = cvt(UInt<4>("hf")) @[FloatingPointMultiply.scala 41:65]
        node _expResult_T_6 = sub(_expResult_T_4, _expResult_T_5) @[FloatingPointMultiply.scala 41:48]
        node _expResult_T_7 = tail(_expResult_T_6, 1) @[FloatingPointMultiply.scala 41:48]
        node _expResult_T_8 = asSInt(_expResult_T_7) @[FloatingPointMultiply.scala 41:48]
        node expResult = asUInt(_expResult_T_8) @[FloatingPointMultiply.scala 41:75]
        node _sigResult_T = mul(sigA, sigB) @[FloatingPointMultiply.scala 42:27]
        node sigResult = bits(_sigResult_T, 21, 10) @[FloatingPointMultiply.scala 42:34]
        node _T_2 = bits(expResult, 5, 5) @[FloatingPointMultiply.scala 45:19]
        when _T_2 : @[FloatingPointMultiply.scala 45:24]
          io.result <= UInt<1>("h0") @[FloatingPointMultiply.scala 47:17]
        else :
          node _T_3 = gt(expResult, UInt<5>("h1e")) @[FloatingPointMultiply.scala 48:26]
          when _T_3 : @[FloatingPointMultiply.scala 48:40]
            node io_result_hi_1 = cat(newSign, UInt<5>("h1f")) @[Cat.scala 33:92]
            node _io_result_T_2 = cat(io_result_hi_1, UInt<10>("h0")) @[Cat.scala 33:92]
            io.result <= _io_result_T_2 @[FloatingPointMultiply.scala 50:17]
          else :
            node _io_result_T_3 = bits(expResult, 4, 0) @[FloatingPointMultiply.scala 53:42]
            node _io_result_T_4 = bits(sigResult, 9, 0) @[FloatingPointMultiply.scala 53:59]
            node io_result_hi_2 = cat(newSign, _io_result_T_3) @[Cat.scala 33:92]
            node _io_result_T_5 = cat(io_result_hi_2, _io_result_T_4) @[Cat.scala 33:92]
            io.result <= _io_result_T_5 @[FloatingPointMultiply.scala 53:17]


